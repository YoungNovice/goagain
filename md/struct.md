### struct

* go中的struct跟c中的struct很相似 go没有class
* type xxx struct {}定义
* 支持指向自身的指针类型成员
* 支持匿名结构 可用做成员或者定义成员变量
* 匿名结构也可以用于map的值
* 可以使用字面值对结构初始化
* 允许通过指针来读写成员
* 相同类型成员可以直接拷贝赋值
* 支持 == != 比较运算符 
* 支持匿名字段 本质上是定义了一个以某个类型名为名称的字段
* 嵌入结构作为匿名字段看起来像继承 但不是
* 可以使用匿名字段指针

### 方法method

Go 中虽没有class，但依旧有method
通过显示说明receiver来实现与某个类型的组合
只能为同一个包中的类型定义方法
Receiver 可以是类型的值或者指针
不存在方法重载
可以使用值或指针来调用方法，编译器会自动完成转换
从某种意义上来说，方法是函数的语法糖，因为receiver其实就是
方法所接收的第1个参数（Method Value vs. Method Expression）
如果外部结构和嵌入结构存在同名方法，则优先调用外部结构的方法
类型别名不会拥有底层类型所附带的方法
方法可以调用结构中的非公开字段

### 接口interface

接口是一个或多个方法签名的集合
只要某个类型拥有该接口的所有方法签名，即算实现该接口，无需显示
声明实现了哪个接口，这称为 Structural Typing
接口只有方法声明，没有实现，没有数据字段
接口可以匿名嵌入其它接口，或嵌入到结构中
将对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个
复制品的指针，既无法修改复制品的状态，也无法获取指针
只有当接口存储的类型和对象都为nil时，接口才等于nil
接口调用不会做receiver的自动转换
接口同样支持匿名字段方法
接口也可实现类似OOP中的多态
空接口可以作为任何类型数据的容器

反射reflection

反射可大大提高程序的灵活性，使得 interface{} 有更大的发挥余地
反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息
反射会将匿名字段作为独立字段（匿名字段本质）
想要利用反射修改对象状态，前提是 interface.data 是 settable，
即 pointer-interface
- 通过反射可以“动态”调用方法



